import * as fs from 'fs';
import * as pg from 'pg';
import { ExtractedColumn, ExtractedSchema, ExtractedTable, ExtractedView } from './extraction-interfaces';
import { Queries } from './extraction-queries';
function t(s: string) {
  return `'${s}' as '${s}'`;
}
export class SchemaExtractor {
  constructor(private pool: pg.Pool) { }
  public async extract(destination: string, schemas: string[]) {
    const gatheredSchemas = await new Queries(this.pool).gather({ schemas });

    const lines = [
      `
// this file is generated by Morbid to input into a Morbid client which uses generics to extract type-information for typescript

export const Def = {`,
      '  schemas: {',
      ...Array.from(gatheredSchemas.values()).map(schema => this.renderSchema(schema.schema, schema)),
      '  },',
      '};',
    ].join('\n') + '\n';
    fs.writeFileSync(destination + '.ts', lines);
  }
  private renderColumn(name: string, extract: ExtractedColumn) {
    const type = `${extract.type.replace(/"/gm, '\\"')}`;
    return [
      `            ${name}: {`,
      `              name: ${t(name)},`,
      `              type: ${t(type)},`,
      `              nullable: ${t(extract.nullable ? 'T' : 'F')},`,
      '            },',
    ].join('\n');
  }
  /*
  private renderIndex(name: string, extract: ExtractedIndex) {
    return [
      `            ${name}: {`,
      `              name: s("${name}"),`,
      `              struct: s("${extract.struct}"),`,
      `              unique: b("${extract.unique}"),`,
      `              columns: l(${extract.cols.map(c => `"${c}"`).join(', ')}),`,
      '            },',
    ].join('\n');
  }
  */
  private renderTable(name: string, extract: ExtractedTable) {
    return [
      `        ${name}: {`,
      `          name: ${t(name)},`,
      '          columns: {',
      ...extract.columns.map(c => this.renderColumn(c.columnname, c)),
      '          },',
      '          indices: {',
      '          },',
      '        },',
    ].join('\n');
  }
  private renderView(name: string, extract: ExtractedView) {
    return [
      `        ${name}: {`,
      `          name: ${t(name)},`,
      '          columns: {',
      ...extract.columns.map(c => this.renderColumn(c.columnname, c)),
      '          },',
      '          indices: {',
      '          },',
      '        },',
    ].join('\n');
  }
  private renderSchema(name: string, extract: ExtractedSchema) {
    return [
      `    ${name}: {`,
      `      name: ${t(name)},`,
      '      tables: {',
      ...extract.tables.map(t => this.renderTable(t.tablename, t)),
      '      },',
      '      views: {',
      ...extract.views.map(t => this.renderView(t.viewname, t)),
      '      },',
      '    },',
    ].join('\n');
  }
}
